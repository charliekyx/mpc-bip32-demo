bip32: 通过一个随机种子 (Seed) 生成一棵由无数个私钥和公钥组成的树状结构

BIP32 引入了“父钥” (Parent Key) 和“子钥” (Child Key) 的概念。
    根 (Root): 一切起源于一个 Seed（通常由 BIP39 助记词生成）。
    主节点 (Master Node): 由 Seed 生成主私钥 (m) 和 主链码 (Master Chain Code)。
    衍生 (Derivation): 通过父私钥，我们可以计算出子私钥；通过父公钥，我们可以计算出子公钥
    
路径path示例: m/0/1/5（主密钥 -> 第0个子密钥 -> 第1个孙密钥 -> 第5个重孙密钥)

** xprv (Extended Private Key) **
包含：私钥 + 链码 chian code
能力：可以衍生所有的子私钥和子公钥
必须绝对保密

** xpub (Extended Public Key) **
包含：公钥 + 链码 chain code
能力：只能衍生子公钥（生成收款地址），无法推导出任何私钥。
用途： 这种特性非常适合电商服务器或审计。可以把 xpub 放在不安全的服务器上生成收款地址，即使服务器被黑，黑客也只能看到地址，而无法花费资金

** 两种衍生方式 (Derivation Types) **
 BIP32 中最关键的安全概念，分为 
    普通衍生 (Normal Derivation) Lockness (CGGMP24) 目前仅支持 Normal Derivation (普通衍生)
        特性: 只要拥有父扩展公钥 (Parent xpub)，就可以计算出所有子公钥。
        安全风险 (提权漏洞): 这是一个数学上的特性。如果攻击者同时知道了 “子私钥” 和 “父扩展公钥 (Parent xpub)”，通过数学运算，他可以反向推导出 “父私钥”。这意味着如果你的某个子私钥泄露，整棵树（及主私钥）都可能面临风险
    强化衍生 (Hardened Derivation)
        通常用 ' 或 h 标记（例如 0' 或 0h）
        特性: 这种模式打断了父公钥和子公钥之间的数学联系。必须拥有父私钥才能推导出子公钥
        优势: 即使“子私钥”和“父扩展公钥”同时泄露，攻击者也无法推导出“父私钥”

** 为什么Lockness不支持 Hardened？**
Hardened 的定义 (BIP32): 计算子密钥需要使用 父私钥 (Parent Private Key) 进行哈希运算。 公式核心：Hash(ParentPrivateKey, ChainCode, Index)
MPC 的矛盾: MPC 的核心宗旨是 “没有任何人知道完整的私钥”。 既然没有人知道 ParentPrivateKey，也就没有任何一个节点能在本地算出那个哈希值。

** MPC BIP32的难点：
    无法高效做强化衍生（因为无法对未知的私钥做哈希）
    需要极其小心的数学协调来保证分片偏移后的 ZKP 依然有效，这一步很容易写错，不封装起来写错了容易被别的节点认为是坏节点

** 为什么Lockness要明确说明自己支持hd Wallet
安全性闭环：它的 ZKP 证明已经覆盖了 Derivation 的逻辑。开发者不需要担心因为加了 Tweak 而导致协议崩溃或私钥泄露


** BIP32 概念在 Lockness/CGGMP24 环境下的映射 **
Seed (种子) => 无单一 Seed, 在 MPC 中，大家不共享一个助记词。相反，大家通过 DKG (分布式密钥生成) 协议共同协商出一个“虚拟”的 Seed 或主私钥，但谁都不知道它是什么
xprv (扩展私钥) => Key Shares (密钥分片), 完整的 xprv 被数学拆分（Sharding）
xpub (扩展公钥) => Global Public Key + Chain Code, 所有人都可以知道共同的主公钥和链码（Chain Code）。这一点与传统钱包一样，是公开信息
Derivation (衍生) => Protocol / Local Update 衍生不再是一个人的计算，而是通过协议让各方更新自己手里的分片，使得它们的新总和等于子私钥。

** 如何在不知道私钥的情况下“衍生”出子私钥？**
BIP32 的子私钥计算公式: ChildPrivKey = ParentPrivKey + hash(ParentPubKey, ChainCode, Index).left(32)
ParentPubKey 和 Chain Code 是公开的，所有参与方（Party A, Party B...）都可以在本地独立算出这个hash的部分


** Derivation 如何通过path完成？cggmp24运作的伪代码 **
// 初始状态：站在 "m" 这一层
let mut current_pubkey = root_pubkey;
let mut current_chain_code = root_chain_code;
let mut total_tweak = 0; // 累计的偏移量

// 假设路径是 [44, 0, 0]
let path = vec![44, 0, 0];

for index in path {
    // 1. 准备哈希的输入数据
    // 注意：上一轮的输出，变成了这一轮的输入
    let input = (current_pubkey, current_chain_code, index);
    
    // 2. 算出这一层的哈希结果 (HMAC-SHA512)
    // tweak 就是 IL
    // new_chain_code 就是 IR
    let (tweak, new_chain_code) = hmac_sha512(input);
    
    // 3. 更新状态，准备进入下一轮循环
    
    // 把这一层的偏移量加到公钥上，变成下一层的公钥
    current_pubkey = current_pubkey + tweak * G; 
    
    // 更新链码，下一层要用新的链码
    current_chain_code = new_chain_code;
    
    // 累加偏移量 (给 MPC 私钥分片用的)
    total_tweak = total_tweak + tweak;
}


*HD Wallet (BIP32) 相比普通 MPC，在 Lockness/CGGMP24 的实现中，增加了 0 轮额外的网络交互*
普通的 DKG 的时候本身就需要各方生成随机数做Commitment,
开启 HD Wallet 后，各方只是在生成私钥分片随机数的同时，并行生成了用于 Chain Code 的随机数。
这些额外的随机数被打包在同一个数据包中发送。因此，协议的轮次（Rounds）保持不变，只是消息体（Payload）变大了一点（多了 32 字节的熵）。

private parent key => private child key 
public parent key => public child key 
chaincode是随机生成的吗？具体

** 倒出来bip32支持导出总私钥，chaincode也会被导出吗，倒入到metamask里面也会识别chaincode吗 **
MetaMask 不需要“知道”这是一套 BIP-32 钱包，因为它默认假定所有导入的助记词都遵循 BIP-32/39/44 行业标准
12 个助记词（本质上是一个 128位的随机数）
根据bip32的公式，计算出一个chaincode
因为倒入的seed在这个阶段并不是随机的，那么按照固定的公式，metamask就可以算出和dkg结果一样的chaincode
注意: master private key 和 chain code用的是同一个seed
(bip32 wiki reference) "Use parse256(IL) as master secret key, and IR as master chain code."

** 验证cggmp弄的是正确性 ** 
交易验证成功
使用一个标准的、独立的 BIP32 库（不涉及 MPC，纯数学推导）来重演公钥衍生过程，成功
==> refer to verify_bip32.py


cggmp源代码: https://github.com/LFDT-Lockness/hd-wallet/blob/m/src/lib.rs#L436

1. CKDpriv: Private Parent ==> Private Child 代码639行

fn derive_child_key_pair(
    parent_key: &ExtendedKeyPair<E>,
    child_index: impl Into<ChildIndex>,
) -> ExtendedKeyPair<E> {
    let child_index = child_index.into();

    // 步骤 1: 计算 I (即 Shift)
    // 这里体现了 BIP-32 中根据是否 Hardened 选择不同的 HMAC 输入数据
    let shift = match child_index {
        ChildIndex::Hardened(i) => Self::derive_hardened_shift(parent_key, i),
        ChildIndex::NonHardened(i) => Self::derive_public_shift(&parent_key.public_key, i),
    };

    // 步骤 2: 计算子私钥 k_i
    // 对应公式: k_i = k_par + I_L
    let mut child_sk = &parent_key.secret_key.secret_key + shift.shift;
    let child_sk = SecretScalar::new(&mut child_sk);

    // 步骤 3: 构造返回结果 (包含 c_i)
    ExtendedKeyPair {
        secret_key: ExtendedSecretKey {
            secret_key: child_sk,
            chain_code: shift.child_public_key.chain_code,
        },
        public_key: shift.child_public_key,
    }
}

2. CKDpub: Public Parent ==> Public Child

fn derive_child_public_key(
    parent_public_key: &ExtendedPublicKey<E>,
    child_index: NonHardenedIndex, // 类型系统强制保证了 index 只能是 Non-Hardened
) -> ExtendedPublicKey<E> {
    Self::derive_public_shift(parent_public_key, child_index).child_public_key
}


https://github.com/LFDT-Lockness/hd-wallet/blob/m/src/slip10.rs
** 如何生成chaincode？**

** 生成 root chaincode**

* a. 生成随机数
#[cfg(feature = "hd-wallet")]
let chain_code_local = if hd_enabled {
    let mut chain_code = hd_wallet::ChainCode::default();
    rng.fill_bytes(&mut chain_code); // 生成本地随机部分
    Some(chain_code)
} else {
    None
};
* b. 提取I_R
pub fn derive_master_key_with_curve_tag<E: generic_ec::Curve>(
    curve_tag: &[u8],
    seed: &[u8],
) -> Result<crate::ExtendedSecretKey<E>, crate::errors::InvalidLength> {
    if !(16 <= seed.len() && seed.len() <= 64) {
        return Err(crate::errors::InvalidLength);
    }

    let hmac = HmacSha512::new_from_slice(curve_tag)
        .expect("this never fails: hmac can handle keys of any size");
    let mut i = hmac.clone().chain_update(seed).finalize().into_bytes();

    loop {
        let (i_left, i_right) = split_into_two_halves(&i);

        if let Ok(mut sk) = generic_ec::Scalar::<E>::from_be_bytes(i_left) {
            if !bool::from(subtle::ConstantTimeEq::ct_eq(
                &sk,
                &generic_ec::Scalar::zero(),
            )) {
                return Ok(crate::ExtendedSecretKey {
                    secret_key: generic_ec::SecretScalar::new(&mut sk),
                    chain_code: (*i_right).into(),
                });
            }
        }

        i = hmac.clone().chain_update(&i[..]).finalize().into_bytes()
    }
}


** 计算衍生的部分 **

pub struct DerivedShift<E: Curve> {
    /// Derived shift
    pub shift: Scalar<E>,
    /// Derived child extended public key
    pub child_public_key: ExtendedPublicKey<E>,
}

pub struct ExtendedPublicKey<E: Curve> {
    /// The public key that can be used for signature verification
    pub public_key: Point<E>,
    /// A chain code that is used to derive child keys
    pub chain_code: ChainCode,
}


fn derive_public_shift_for_any_curve<E: Curve>(
    parent_public_key: &ExtendedPublicKey<E>,
    child_index: NonHardenedIndex,
) -> DerivedShift<E> {
    let hmac = HmacSha512::new_from_slice(&parent_public_key.chain_code)
        .expect("this never fails: hmac can handle keys of any size");
    let i = hmac
        .clone()
        .chain_update(parent_public_key.public_key.to_bytes(true))
        .chain_update(child_index.to_be_bytes())
        .finalize()
        .into_bytes();
    Self::calculate_shift_for_any_curve(&hmac, parent_public_key, *child_index, i)
}


fn calculate_shift_for_any_curve<E: Curve>(
        hmac: &HmacSha512,
        parent_public_key: &ExtendedPublicKey<E>,
        child_index: u32,
        mut i: hmac::digest::Output<HmacSha512>,
    ) -> DerivedShift<E> {
        loop {
            let (i_left, i_right) = split_into_two_halves(&i);

            if let Ok(shift) = Scalar::<E>::from_be_bytes(i_left) {
                let child_pk = parent_public_key.public_key + Point::generator() * shift;
                if !child_pk.is_zero() {
                    return DerivedShift {
                        shift,
                        child_public_key: ExtendedPublicKey {
                            public_key: child_pk,
                            chain_code: (*i_right).into(),
                        },
                    };
                }
            }

            i = hmac
                .clone()
                .chain_update([0x01])
                .chain_update(i_right)
                .chain_update(child_index.to_be_bytes())
                .finalize()
                .into_bytes()
        }
    }